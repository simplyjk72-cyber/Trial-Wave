<!DOCTYPE html>
<html>
<head>
<title>Playable Wave</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let gameState = "playing";
let score = 0;
let highScore = localStorage.getItem("waveHighScore") || 0;
let lastScoreTime = Date.now();

let baseSpeed = 6; // Slower = playable
let speedMultiplier = 1;

let player = {
  x: 200,
  y: canvas.height / 2,
  size: 14,
  hitbox: 10 // smaller hitbox like GD
};

let holding = false;

let segments = [];
let segmentWidth = 140;
let gapSize = 180; // MUCH BIGGER GAP
let spawnX = canvas.width;

// -------- GD STYLE HITBOX ----------
function triangleCollision(px, py, size, t) {
  let cx = px + size / 2;
  let cy = py + size / 2;

  let area = Math.abs((t.x2 - t.x1)*(t.y3 - t.y1) - (t.x3 - t.x1)*(t.y2 - t.y1));
  let a1 = Math.abs((t.x1 - cx)*(t.y2 - cy) - (t.x2 - cx)*(t.y1 - cy));
  let a2 = Math.abs((t.x2 - cx)*(t.y3 - cy) - (t.x3 - cx)*(t.y2 - cy));
  let a3 = Math.abs((t.x3 - cx)*(t.y1 - cy) - (t.x1 - cx)*(t.y3 - cy));

  return Math.abs(area - (a1 + a2 + a3)) < 1;
}

// -------- SPAWN CONNECTED TRIANGLES ----------
function spawnSegment() {
  segments.push({
    x: spawnX,
    direction: segments.length % 2 === 0 ? "down" : "up",
  });
  spawnX += segmentWidth;
}

for (let i = 0; i < 15; i++) spawnSegment();

// -------- INPUT ----------
function startHold(){ if(gameState==="playing") holding=true; }
function stopHold(){ holding=false; }

document.addEventListener("keydown", e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) startHold();
  if(e.key==="r") location.reload();
});
document.addEventListener("keyup", e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) stopHold();
});
document.addEventListener("mousedown", e=>{ if(e.button===0) startHold(); });
document.addEventListener("mouseup", e=>{ if(e.button===0) stopHold(); });

// -------- UPDATE ----------
function update(){

  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(gameState==="dead"){
    ctx.fillStyle="white";
    ctx.font="40px Arial";
    ctx.fillText("GIT GUD - PRESS R", canvas.width/2-180, canvas.height/2);
    requestAnimationFrame(update);
    return;
  }

  // Score every 0.5s
  let now = Date.now();
  if(now - lastScoreTime >= 500){
    score++;
    lastScoreTime = now;

    // Gradual difficulty increase
    if(score % 20 === 0 && gapSize > 110){
      gapSize -= 10; // slowly tighter
    }
    if(score % 30 === 0){
      speedMultiplier += 0.1;
    }
  }

  if(score > highScore){
    highScore = score;
    localStorage.setItem("waveHighScore", highScore);
  }

  let speed = baseSpeed * speedMultiplier;

  // REAL WAVE FEEL (constant diagonal speed)
  let waveSpeed = 5 * speedMultiplier;

  if(holding) player.y -= waveSpeed;
  else player.y += waveSpeed;

  ctx.fillStyle="cyan";
  ctx.fillRect(player.x, player.y, player.size, player.size);

  for(let s of segments){
    s.x -= speed;

    let center = canvas.height / 2;
    let halfGap = gapSize / 2;

    let t;

    if(s.direction === "down"){
      t = {
        x1: s.x,
        y1: 0,
        x2: s.x + segmentWidth,
        y2: 0,
        x3: s.x + segmentWidth,
        y3: center - halfGap
      };
    } else {
      t = {
        x1: s.x,
        y1: canvas.height,
        x2: s.x + segmentWidth,
        y2: canvas.height,
        x3: s.x + segmentWidth,
        y3: center + halfGap
      };
    }

    ctx.fillStyle="orange";
    ctx.beginPath();
    ctx.moveTo(t.x1, t.y1);
    ctx.lineTo(t.x2, t.y2);
    ctx.lineTo(t.x3, t.y3);
    ctx.closePath();
    ctx.fill();

    if(triangleCollision(player.x + 2, player.y + 2, player.hitbox, t))
      gameState="dead";

    if(s.x < -segmentWidth) spawnSegment();
  }

  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText("Score: "+score, 20, 40);
  ctx.fillText("Highscore: "+highScore, 150, 40);

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>

</script>
</body>
</html>

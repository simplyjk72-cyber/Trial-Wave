<!DOCTYPE html>
<html>
<head>
<title>Unskippable Mini Wave</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let gameState = "playing";

let speed = 12;                 // fast
let segmentWidth = 40;          // rapid switches
let amplitude = 90;             // strong angle
let gapSize = 60;               // tight (hard)

let player = {
  x: 200,
  y: canvas.height/2,
  size: 6,
  hitbox: 4
};

let holding = false;
let segments = [];
let spawnX = canvas.width;

let baseY = canvas.height/2;
let dir = 1; // alternates every segment

// ---- LINE COLLISION ----
function lineCollision(px, py, size, x1, y1, x2, y2){
  let cx = px + size/2;
  let cy = py + size/2;

  let dx = x2 - x1;
  let dy = y2 - y1;
  let length = Math.sqrt(dx*dx + dy*dy);

  let dot = ((cx-x1)*dx + (cy-y1)*dy) / (length*length);
  dot = Math.max(0, Math.min(1, dot));

  let closestX = x1 + dot*dx;
  let closestY = y1 + dot*dy;

  let distX = cx - closestX;
  let distY = cy - closestY;
  let distance = Math.sqrt(distX*distX + distY*distY);

  return distance < player.hitbox/2;
}

// ---- FORCE PERFECT ZIGZAG ----
function spawnSegment(){

  let offset = dir * amplitude;

  let centerY = baseY + offset;

  if(centerY < 120) centerY = 120;
  if(centerY > canvas.height-120) centerY = canvas.height-120;

  let top = centerY - gapSize/2;
  let bottom = centerY + gapSize/2;

  segments.push({
    x: spawnX,
    prevTop: baseY - gapSize/2,
    prevBottom: baseY + gapSize/2,
    top: top,
    bottom: bottom
  });

  baseY = centerY;
  spawnX += segmentWidth;
  dir *= -1;  // ALWAYS flip
}

for(let i=0;i<60;i++) spawnSegment();

// ---- INPUT ----
document.addEventListener("keydown", e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) holding=true;
  if(e.key==="r") location.reload();
});
document.addEventListener("keyup", e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) holding=false;
});
document.addEventListener("mousedown", ()=> holding=true);
document.addEventListener("mouseup", ()=> holding=false);

// ---- UPDATE ----
function update(){

  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(gameState==="dead"){
    ctx.fillStyle="white";
    ctx.font="40px Arial";
    ctx.fillText("PRESS R", canvas.width/2-100, canvas.height/2);
    requestAnimationFrame(update);
    return;
  }

  // Wave movement (true 45Â° feel)
  let waveSpeed = 8;

  if(holding) player.y -= waveSpeed;
  else player.y += waveSpeed;

  // Visible borders
  ctx.fillStyle="red";
  ctx.fillRect(0,0,canvas.width,6);
  ctx.fillRect(0,canvas.height-6,canvas.width,6);

  if(player.y < 6 || player.y + player.size > canvas.height-6){
    gameState="dead";
  }

  // Draw player
  ctx.fillStyle="cyan";
  ctx.fillRect(player.x, player.y, player.size, player.size);

  for(let s of segments){

    s.x -= speed;

    ctx.strokeStyle="orange";
    ctx.lineWidth=3;

    ctx.beginPath();
    ctx.moveTo(s.x, s.prevTop);
    ctx.lineTo(s.x + segmentWidth, s.top);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(s.x, s.prevBottom);
    ctx.lineTo(s.x + segmentWidth, s.bottom);
    ctx.stroke();

    if(
      lineCollision(player.x, player.y, player.size,
        s.x, s.prevTop,
        s.x+segmentWidth, s.top
      ) ||
      lineCollision(player.x, player.y, player.size,
        s.x, s.prevBottom,
        s.x+segmentWidth, s.bottom
      )
    ){
      gameState="dead";
    }

    if(s.x < -segmentWidth){
      segments.shift();
      spawnSegment();
    }
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>

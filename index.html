<!DOCTYPE html>
<html>
<head>
<title>Wave - Easy to Insane</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let gameState = "playing";
let score = 0;
let highScore = localStorage.getItem("waveHighScore") || 0;
let lastScoreTime = Date.now();

let baseSpeed = 8;            // fast but controllable
let speedMultiplier = 1;

let player = {
  x: 200,
  y: canvas.height/2,
  size: 14,
  hitbox: 8
};

let holding = false;

let segments = [];
let segmentWidth = 80;
let gapSize = 160;            // easy start
let spawnX = canvas.width;
let lastCenterY = canvas.height/2;

// -------- LINE COLLISION --------
function lineCollision(px, py, size, x1, y1, x2, y2){
  let cx = px + size/2;
  let cy = py + size/2;

  let dx = x2 - x1;
  let dy = y2 - y1;
  let length = Math.sqrt(dx*dx + dy*dy);

  let dot = ((cx-x1)*dx + (cy-y1)*dy) / (length*length);
  dot = Math.max(0, Math.min(1, dot));

  let closestX = x1 + dot*dx;
  let closestY = y1 + dot*dy;

  let distX = cx - closestX;
  let distY = cy - closestY;
  let distance = Math.sqrt(distX*distX + distY*distY);

  return distance < player.hitbox/2;
}

// -------- SPAWN CONNECTED SLOPES --------
function spawnSegment(){

  let shift = (Math.random()*140 - 70);
  let centerY = lastCenterY + shift;

  // Keep inside visible borders
  centerY = Math.max(120, Math.min(canvas.height-120, centerY));

  let top = centerY - gapSize/2;
  let bottom = centerY + gapSize/2;

  segments.push({
    x: spawnX,
    prevTop: lastCenterY - gapSize/2,
    prevBottom: lastCenterY + gapSize/2,
    top: top,
    bottom: bottom
  });

  lastCenterY = centerY;
  spawnX += segmentWidth;
}

for(let i=0;i<25;i++) spawnSegment();

// -------- INPUT --------
function startHold(){ if(gameState==="playing") holding=true; }
function stopHold(){ holding=false; }

document.addEventListener("keydown", e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) startHold();
  if(e.key==="r") location.reload();
});
document.addEventListener("keyup", e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) stopHold();
});
document.addEventListener("mousedown", e=>{ if(e.button===0) startHold(); });
document.addEventListener("mouseup", e=>{ if(e.button===0) stopHold(); });

// -------- UPDATE LOOP --------
function update(){

  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(gameState==="dead"){
    ctx.fillStyle="white";
    ctx.font="40px Arial";
    ctx.fillText("INSANE - PRESS R", canvas.width/2-170, canvas.height/2);
    requestAnimationFrame(update);
    return;
  }

  // ---- Score & Scaling ----
  let now = Date.now();
  if(now-lastScoreTime >= 500){
    score++;
    lastScoreTime = now;

    // tighten gap gradually â†’ insane
    if(score % 8 === 0 && gapSize > 70){
      gapSize -= 6;
    }

    // increase speed
    if(score % 12 === 0){
      speedMultiplier += 0.12;
    }
  }

  if(score > highScore){
    highScore = score;
    localStorage.setItem("waveHighScore", highScore);
  }

  let speed = baseSpeed * speedMultiplier;
  let waveSpeed = 6.5 * speedMultiplier;

  if(holding) player.y -= waveSpeed;
  else player.y += waveSpeed;

  // ---- VISIBLE BORDERS ----
  ctx.fillStyle = "red";
  ctx.fillRect(0,0,canvas.width,6); // top border
  ctx.fillRect(0,canvas.height-6,canvas.width,6); // bottom border

  // Border collision
  if(player.y < 6 || player.y + player.size > canvas.height-6){
    gameState = "dead";
  }

  // Player
  ctx.fillStyle="cyan";
  ctx.fillRect(player.x, player.y, player.size, player.size);

  // Slopes
  for(let s of segments){

    s.x -= speed;

    ctx.strokeStyle="orange";
    ctx.lineWidth=4;

    ctx.beginPath();
    ctx.moveTo(s.x, s.prevTop);
    ctx.lineTo(s.x + segmentWidth, s.top);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(s.x, s.prevBottom);
    ctx.lineTo(s.x + segmentWidth, s.bottom);
    ctx.stroke();

    if(
      lineCollision(player.x, player.y, player.size,
        s.x, s.prevTop,
        s.x+segmentWidth, s.top
      ) ||
      lineCollision(player.x, player.y, player.size,
        s.x, s.prevBottom,
        s.x+segmentWidth, s.bottom
      )
    ){
      gameState="dead";
    }

    if(s.x < -segmentWidth){
      segments.shift();
      spawnSegment();
    }
  }

  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText("Score: "+score, 20, 40);
  ctx.fillText("Highscore: "+highScore, 150, 40);

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<title>Wave Game</title>
<style>
body { margin:0; overflow:hidden; background:black; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let gameState="playing";
let score=0;
let highScore=localStorage.getItem("waveHighScore")||0;
let lastScoreTime=Date.now();

let baseSpeed=4;
let speedMultiplier=1;
let speedLevels=[0.5,1,2,3,4];

let player={
  x:150,
  y:canvas.height/2,
  normalSize:16,
  miniSize:8,
  size:16,
  isMini:false
};

let holding=false;
let borderTime=0;

let obstacles=[];
let portals=[];
let spawnX=canvas.width;

function spawnChunk(){

  // Always spawn obstacle
  obstacles.push({
    type:"block",
    x:spawnX,
    y:Math.random()*(canvas.height-250),
    width:30,
    height:200
  });

  // Alternating ramps
  let up = Math.random()<0.5;
  obstacles.push({
    type:"ramp",
    x:spawnX+150,
    width:140,
    height:140,
    direction:up?"up":"down"
  });

  // Spikes
  obstacles.push({
    type:"spike",
    x:spawnX+300,
    size:35,
    y:canvas.height-5
  });

  spawnX+=500;
}

for(let i=0;i<8;i++) spawnChunk();

function spawnPortal(){
  let type=Math.random()<0.5?"speed":"size";

  let portal={
    x:spawnX,
    width:40,
    height:canvas.height,
    type:type
  };

  if(type==="speed"){
    let possible=speedLevels.filter(s=>s!==speedMultiplier);
    portal.value=possible[Math.floor(Math.random()*possible.length)];
  }else{
    portal.value=player.isMini?"normal":"mini";
  }

  portals.push(portal);
  spawnX+=200;
}

function reset(){
  score=0;
  speedMultiplier=1;
  player.isMini=false;
  player.size=player.normalSize;
  player.y=canvas.height/2;
  lastScoreTime=Date.now();
  borderTime=0;
  gameState="playing";
  obstacles=[];
  portals=[];
  spawnX=canvas.width;
  for(let i=0;i<8;i++) spawnChunk();
}

function startHold(){ if(gameState==="playing") holding=true; }
function stopHold(){ holding=false; }

document.addEventListener("keydown",e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) startHold();
  if(e.key==="r") reset();
});
document.addEventListener("keyup",e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) stopHold();
});
document.addEventListener("mousedown",e=>{ if(e.button===0) startHold(); });
document.addEventListener("mouseup",e=>{ if(e.button===0) stopHold(); });

function rectCollision(a,b){
  return(
    a.x < b.x + b.width &&
    a.x + a.size > b.x &&
    a.y < b.y + b.height &&
    a.y + a.size > b.y
  );
}

function update(){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(gameState==="dead"){
    ctx.fillStyle="white";
    ctx.font="40px Arial";
    ctx.fillText("You Died - Press R",canvas.width/2-170,canvas.height/2);
    requestAnimationFrame(update);
    return;
  }

  let now=Date.now();
  if(now-lastScoreTime>=500){
    score++;
    lastScoreTime=now;
    if(score%50===0) spawnPortal();
  }

  if(score>highScore){
    highScore=score;
    localStorage.setItem("waveHighScore",highScore);
  }

  let speed=baseSpeed*speedMultiplier;

  // Y movement scales with speed
  if(holding) player.y-=3*speedMultiplier;
  else player.y+=3*speedMultiplier;

  if(player.y<=5||player.y+player.size>=canvas.height-5){
    borderTime++;
    if(borderTime>40) gameState="dead";
  }else borderTime=0;

  if(player.y<5) player.y=5;
  if(player.y+player.size>canvas.height-5)
    player.y=canvas.height-player.size-5;

  ctx.fillStyle="white";
  ctx.fillRect(0,0,canvas.width,5);
  ctx.fillRect(0,canvas.height-5,canvas.width,5);

  ctx.font="20px Arial";
  ctx.fillText("Score: "+score,20,40);
  ctx.fillText("Highscore: "+highScore,160,40);

  ctx.fillStyle="cyan";
  ctx.fillRect(player.x,player.y,player.size,player.size);

  for(let o of obstacles){
    o.x-=speed;

    if(o.type==="block"){
      ctx.fillStyle="red";
      ctx.fillRect(o.x,o.y,o.width,o.height);
      if(rectCollision(player,o)) gameState="dead";
    }

    if(o.type==="ramp"){
      ctx.fillStyle="orange";
      ctx.beginPath();
      if(o.direction==="up"){
        ctx.moveTo(o.x,canvas.height-5);
        ctx.lineTo(o.x+o.width,canvas.height-5);
        ctx.lineTo(o.x+o.width,canvas.height-5-o.height);
      }else{
        ctx.moveTo(o.x,5);
        ctx.lineTo(o.x+o.width,5);
        ctx.lineTo(o.x+o.width,5+o.height);
      }
      ctx.closePath();
      ctx.fill();

      if(player.x+player.size>o.x &&
         player.x<o.x+o.width){
           gameState="dead";
      }
    }

    if(o.type==="spike"){
      ctx.fillStyle="yellow";
      ctx.beginPath();
      ctx.moveTo(o.x,o.y);
      ctx.lineTo(o.x+o.size/2,o.y-o.size);
      ctx.lineTo(o.x+o.size,o.y);
      ctx.closePath();
      ctx.fill();

      if(player.x+player.size>o.x &&
         player.x<o.x+o.size &&
         player.y+player.size>o.y-o.size)
         gameState="dead";
    }

    if(o.x<-300) spawnChunk();
  }

  // PORTALS (full vertical, unskippable)
  for(let p of portals){
    p.x-=speed;

    ctx.beginPath();
    ctx.strokeStyle = p.type==="speed" ? "cyan":"magenta";
    ctx.lineWidth=6;
    ctx.arc(p.x,canvas.height/2,80,0,Math.PI*2);
    ctx.stroke();

    if(player.x+player.size>p.x-40 &&
       player.x<p.x+40){
         if(p.type==="speed"){
           speedMultiplier=p.value;
         }else{
           if(p.value==="mini"){
             player.isMini=true;
             player.size=player.miniSize;
           }else{
             player.isMini=false;
             player.size=player.normalSize;
           }
         }
         p.x=-9999;
    }
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>

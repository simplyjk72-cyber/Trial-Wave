<!DOCTYPE html>
<html>
<head>
  <title>Wave Game</title>
  <style>
    body { margin:0; overflow:hidden; background:black; }
    canvas { display:block; }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

let gameState = "playing";
let score = 0;
let highScore = localStorage.getItem("waveHighScore") || 0;
let lastScoreTime = Date.now();

let baseSpeed = 4;
let speedMultiplier = 1;
let speedLevels = [0.5,1,2,3,4];

let player = {
  x:150,
  y:canvas.height/2,
  size:16,
  normalSize:16,
  miniSize:8,
  isMini:false
};

let holding = false;
let borderTime = 0;

let obstacles=[];
let ramps=[];
let spikes=[];
let portals=[];

function generateBase(){
  obstacles=[];
  ramps=[];
  spikes=[];
  portals=[];

  for(let i=0;i<10;i++){
    obstacles.push({
      x:canvas.width + i*500,
      y:Math.random()*(canvas.height-300),
      width:30,
      height:220
    });

    ramps.push({
      x:canvas.width + 300 + i*800,
      y:canvas.height-5,
      width:120,
      height:120
    });

    spikes.push({
      x:canvas.width + 200 + i*400,
      y:canvas.height-5,
      size:30
    });
  }
}

generateBase();

function spawnPortal(){
  let type = Math.random()<0.5 ? "speed":"size";

  let portal = {
    x:canvas.width + 300,
    y:canvas.height/2 - 40,
    size:40,
    type:type
  };

  if(type==="speed"){
    let possible = speedLevels.filter(s=>s!==speedMultiplier);
    portal.value = possible[Math.floor(Math.random()*possible.length)];
  }else{
    portal.value = player.isMini ? "normal":"mini";
  }

  portals.push(portal);
}

function reset(){
  score=0;
  speedMultiplier=1;
  player.isMini=false;
  player.size=player.normalSize;
  player.y=canvas.height/2;
  lastScoreTime=Date.now();
  borderTime=0;
  gameState="playing";
  generateBase();
}

function startHold(){ if(gameState==="playing") holding=true; }
function stopHold(){ holding=false; }

document.addEventListener("keydown",e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) startHold();
  if(e.key==="r") reset();
});
document.addEventListener("keyup",e=>{
  if(["Space","KeyW","ArrowUp"].includes(e.code)) stopHold();
});
document.addEventListener("mousedown",e=>{ if(e.button===0) startHold(); });
document.addEventListener("mouseup",e=>{ if(e.button===0) stopHold(); });

function rectCollision(a,b){
  return(
    a.x < b.x + b.width &&
    a.x + a.size > b.x &&
    a.y < b.y + b.height &&
    a.y + a.size > b.y
  );
}

function update(){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(gameState==="dead"){
    ctx.fillStyle="white";
    ctx.font="40px Arial";
    ctx.fillText("You Died - Press R",canvas.width/2-170,canvas.height/2);
    requestAnimationFrame(update);
    return;
  }

  let now=Date.now();
  if(now-lastScoreTime>=500){
    score++;
    lastScoreTime=now;

    if(score%50===0){
      spawnPortal();
    }
  }

  if(score>highScore){
    highScore=score;
    localStorage.setItem("waveHighScore",highScore);
  }

  let speed=baseSpeed*speedMultiplier;

  if(holding) player.y-=3;
  else player.y+=3;

  if(player.y<=5 || player.y+player.size>=canvas.height-5){
    borderTime++;
    if(borderTime>60) gameState="dead";
  }else borderTime=0;

  if(player.y<5) player.y=5;
  if(player.y+player.size>canvas.height-5)
    player.y=canvas.height-player.size-5;

  ctx.fillStyle="white";
  ctx.fillRect(0,0,canvas.width,5);
  ctx.fillRect(0,canvas.height-5,canvas.width,5);

  ctx.font="20px Arial";
  ctx.fillText("Score: "+score,20,40);
  ctx.fillText("Highscore: "+highScore,160,40);

  ctx.fillStyle="cyan";
  ctx.fillRect(player.x,player.y,player.size,player.size);

  for(let o of obstacles){
    o.x-=speed;
    ctx.fillStyle="red";
    ctx.fillRect(o.x,o.y,o.width,o.height);
    if(rectCollision(player,o)) gameState="dead";
  }

  for(let r of ramps){
    r.x-=speed;
    ctx.fillStyle="orange";
    ctx.beginPath();
    ctx.moveTo(r.x,r.y);
    ctx.lineTo(r.x+r.width,r.y);
    ctx.lineTo(r.x+r.width,r.y-r.height);
    ctx.closePath();
    ctx.fill();

    if(
      player.x+player.size>r.x &&
      player.x<r.x+r.width &&
      player.y+player.size>r.y-r.height
    ) gameState="dead";
  }

  for(let s of spikes){
    s.x-=speed;
    ctx.fillStyle="yellow";
    ctx.beginPath();
    ctx.moveTo(s.x,s.y);
    ctx.lineTo(s.x+s.size/2,s.y-s.size);
    ctx.lineTo(s.x+s.size,s.y);
    ctx.closePath();
    ctx.fill();

    if(
      player.x+player.size>s.x &&
      player.x<s.x+s.size &&
      player.y+player.size>s.y-s.size
    ) gameState="dead";
  }

  for(let p of portals){
    p.x-=speed;

    ctx.fillStyle= p.type==="speed" ? "blue":"purple";
    ctx.fillRect(p.x,p.y,p.size,p.size);

    if(
      player.x<p.x+p.size &&
      player.x+player.size>p.x &&
      player.y<p.y+p.size &&
      player.y+player.size>p.y
    ){
      if(p.type==="speed"){
        speedMultiplier=p.value;
      }else{
        if(p.value==="mini"){
          player.isMini=true;
          player.size=player.miniSize;
        }else{
          player.isMini=false;
          player.size=player.normalSize;
        }
      }
      p.x=canvas.width+2000;
    }
  }

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
